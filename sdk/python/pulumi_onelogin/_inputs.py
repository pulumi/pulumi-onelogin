# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AppConfigurationArgs',
    'AppConfigurationArgsDict',
    'AppEnforcementPointArgs',
    'AppEnforcementPointArgsDict',
    'AppEnforcementPointResourceArgs',
    'AppEnforcementPointResourceArgsDict',
    'AppEnforcementPointSessionExpiryFixedArgs',
    'AppEnforcementPointSessionExpiryFixedArgsDict',
    'AppEnforcementPointSessionExpiryInactivityArgs',
    'AppEnforcementPointSessionExpiryInactivityArgsDict',
    'AppParametersArgs',
    'AppParametersArgsDict',
    'AppParametersGroupsArgs',
    'AppParametersGroupsArgsDict',
    'AppProvisioningArgs',
    'AppProvisioningArgsDict',
    'AppSsoArgs',
    'AppSsoArgsDict',
    'AppSsoCertificateArgs',
    'AppSsoCertificateArgsDict',
    'AuthServersConfigurationArgs',
    'AuthServersConfigurationArgsDict',
    'PrivilegesPrivilegeArgs',
    'PrivilegesPrivilegeArgsDict',
    'PrivilegesPrivilegeStatementArgs',
    'PrivilegesPrivilegeStatementArgsDict',
    'ProviderEndpointArgs',
    'ProviderEndpointArgsDict',
    'RiskRulesSourceArgs',
    'RiskRulesSourceArgsDict',
    'GetAppsConfigurationArgs',
    'GetAppsConfigurationArgsDict',
    'GetAppsEnforcementPointArgs',
    'GetAppsEnforcementPointArgsDict',
    'GetAppsEnforcementPointResourceArgs',
    'GetAppsEnforcementPointResourceArgsDict',
    'GetAppsEnforcementPointSessionExpiryFixedArgs',
    'GetAppsEnforcementPointSessionExpiryFixedArgsDict',
    'GetAppsEnforcementPointSessionExpiryInactivityArgs',
    'GetAppsEnforcementPointSessionExpiryInactivityArgsDict',
    'GetAppsFilterArgs',
    'GetAppsFilterArgsDict',
    'GetAppsParametersArgs',
    'GetAppsParametersArgsDict',
    'GetAppsParametersGroupsArgs',
    'GetAppsParametersGroupsArgsDict',
    'GetAppsProvisioningArgs',
    'GetAppsProvisioningArgsDict',
    'GetAppsSsoArgs',
    'GetAppsSsoArgsDict',
    'GetAppsSsoCertificateArgs',
    'GetAppsSsoCertificateArgsDict',
    'GetAuthServersClaimsFilterArgs',
    'GetAuthServersClaimsFilterArgsDict',
    'GetAuthServersConfigurationArgs',
    'GetAuthServersConfigurationArgsDict',
    'GetAuthServersFilterArgs',
    'GetAuthServersFilterArgsDict',
    'GetAuthServersInstanceConfigurationArgs',
    'GetAuthServersInstanceConfigurationArgsDict',
    'GetAuthServersScopesFilterArgs',
    'GetAuthServersScopesFilterArgsDict',
    'GetMappingsActionArgs',
    'GetMappingsActionArgsDict',
    'GetMappingsConditionArgs',
    'GetMappingsConditionArgsDict',
    'GetMappingsFilterArgs',
    'GetMappingsFilterArgsDict',
    'GetPrivilegesFilterArgs',
    'GetPrivilegesFilterArgsDict',
    'GetPrivilegesInstancePrivilegeArgs',
    'GetPrivilegesInstancePrivilegeArgsDict',
    'GetPrivilegesInstancePrivilegeStatementArgs',
    'GetPrivilegesInstancePrivilegeStatementArgsDict',
    'GetPrivilegesPrivilegeArgs',
    'GetPrivilegesPrivilegeArgsDict',
    'GetPrivilegesPrivilegeStatementArgs',
    'GetPrivilegesPrivilegeStatementArgsDict',
    'GetRiskRulesFilterArgs',
    'GetRiskRulesFilterArgsDict',
    'GetRiskRulesInstanceSourceArgs',
    'GetRiskRulesInstanceSourceArgsDict',
    'GetRiskRulesSourceArgs',
    'GetRiskRulesSourceArgsDict',
]

MYPY = False

if not MYPY:
    class AppConfigurationArgsDict(TypedDict):
        access_token_expiration_minutes: NotRequired[pulumi.Input[int]]
        """
        OIDC Apps only Number of minutes the refresh token will be valid for.
        """
        login_url: NotRequired[pulumi.Input[str]]
        """
        OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        """
        oidc_api_version: NotRequired[pulumi.Input[str]]
        oidc_application_type: NotRequired[pulumi.Input[int]]
        """
        OIDC Apps Only
          - 0: Web
          - 1: Native/Mobile
        """
        oidc_encryption_key: NotRequired[pulumi.Input[str]]
        """
        OIDC Apps only
        """
        post_logout_redirect_uri: NotRequired[pulumi.Input[str]]
        """
        OIDC Apps only
        """
        redirect_uri: NotRequired[pulumi.Input[str]]
        """
        OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        """
        refresh_token_expiration_minutes: NotRequired[pulumi.Input[int]]
        """
        Number of minutes the refresh token will be valid for.
        """
        token_endpoint_auth_method: NotRequired[pulumi.Input[int]]
        """
        OIDC Apps only
         - 0: Basic
         - 1: POST
         - 2: None / PKCE
        """
elif False:
    AppConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppConfigurationArgs:
    def __init__(__self__, *,
                 access_token_expiration_minutes: Optional[pulumi.Input[int]] = None,
                 login_url: Optional[pulumi.Input[str]] = None,
                 oidc_api_version: Optional[pulumi.Input[str]] = None,
                 oidc_application_type: Optional[pulumi.Input[int]] = None,
                 oidc_encryption_key: Optional[pulumi.Input[str]] = None,
                 post_logout_redirect_uri: Optional[pulumi.Input[str]] = None,
                 redirect_uri: Optional[pulumi.Input[str]] = None,
                 refresh_token_expiration_minutes: Optional[pulumi.Input[int]] = None,
                 token_endpoint_auth_method: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] access_token_expiration_minutes: OIDC Apps only Number of minutes the refresh token will be valid for.
        :param pulumi.Input[str] login_url: OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        :param pulumi.Input[int] oidc_application_type: OIDC Apps Only
                 - 0: Web
                 - 1: Native/Mobile
        :param pulumi.Input[str] oidc_encryption_key: OIDC Apps only
        :param pulumi.Input[str] post_logout_redirect_uri: OIDC Apps only
        :param pulumi.Input[str] redirect_uri: OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        :param pulumi.Input[int] refresh_token_expiration_minutes: Number of minutes the refresh token will be valid for.
        :param pulumi.Input[int] token_endpoint_auth_method: OIDC Apps only
                - 0: Basic
                - 1: POST
                - 2: None / PKCE
        """
        if access_token_expiration_minutes is not None:
            pulumi.set(__self__, "access_token_expiration_minutes", access_token_expiration_minutes)
        if login_url is not None:
            pulumi.set(__self__, "login_url", login_url)
        if oidc_api_version is not None:
            pulumi.set(__self__, "oidc_api_version", oidc_api_version)
        if oidc_application_type is not None:
            pulumi.set(__self__, "oidc_application_type", oidc_application_type)
        if oidc_encryption_key is not None:
            pulumi.set(__self__, "oidc_encryption_key", oidc_encryption_key)
        if post_logout_redirect_uri is not None:
            pulumi.set(__self__, "post_logout_redirect_uri", post_logout_redirect_uri)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)
        if refresh_token_expiration_minutes is not None:
            pulumi.set(__self__, "refresh_token_expiration_minutes", refresh_token_expiration_minutes)
        if token_endpoint_auth_method is not None:
            pulumi.set(__self__, "token_endpoint_auth_method", token_endpoint_auth_method)

    @property
    @pulumi.getter(name="accessTokenExpirationMinutes")
    def access_token_expiration_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        OIDC Apps only Number of minutes the refresh token will be valid for.
        """
        return pulumi.get(self, "access_token_expiration_minutes")

    @access_token_expiration_minutes.setter
    def access_token_expiration_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "access_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="loginUrl")
    def login_url(self) -> Optional[pulumi.Input[str]]:
        """
        OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        """
        return pulumi.get(self, "login_url")

    @login_url.setter
    def login_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_url", value)

    @property
    @pulumi.getter(name="oidcApiVersion")
    def oidc_api_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oidc_api_version")

    @oidc_api_version.setter
    def oidc_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oidc_api_version", value)

    @property
    @pulumi.getter(name="oidcApplicationType")
    def oidc_application_type(self) -> Optional[pulumi.Input[int]]:
        """
        OIDC Apps Only
          - 0: Web
          - 1: Native/Mobile
        """
        return pulumi.get(self, "oidc_application_type")

    @oidc_application_type.setter
    def oidc_application_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oidc_application_type", value)

    @property
    @pulumi.getter(name="oidcEncryptionKey")
    def oidc_encryption_key(self) -> Optional[pulumi.Input[str]]:
        """
        OIDC Apps only
        """
        return pulumi.get(self, "oidc_encryption_key")

    @oidc_encryption_key.setter
    def oidc_encryption_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oidc_encryption_key", value)

    @property
    @pulumi.getter(name="postLogoutRedirectUri")
    def post_logout_redirect_uri(self) -> Optional[pulumi.Input[str]]:
        """
        OIDC Apps only
        """
        return pulumi.get(self, "post_logout_redirect_uri")

    @post_logout_redirect_uri.setter
    def post_logout_redirect_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_logout_redirect_uri", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[pulumi.Input[str]]:
        """
        OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_uri", value)

    @property
    @pulumi.getter(name="refreshTokenExpirationMinutes")
    def refresh_token_expiration_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Number of minutes the refresh token will be valid for.
        """
        return pulumi.get(self, "refresh_token_expiration_minutes")

    @refresh_token_expiration_minutes.setter
    def refresh_token_expiration_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="tokenEndpointAuthMethod")
    def token_endpoint_auth_method(self) -> Optional[pulumi.Input[int]]:
        """
        OIDC Apps only
         - 0: Basic
         - 1: POST
         - 2: None / PKCE
        """
        return pulumi.get(self, "token_endpoint_auth_method")

    @token_endpoint_auth_method.setter
    def token_endpoint_auth_method(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "token_endpoint_auth_method", value)


if not MYPY:
    class AppEnforcementPointArgsDict(TypedDict):
        case_sensitive: NotRequired[pulumi.Input[bool]]
        """
        The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        """
        conditions: NotRequired[pulumi.Input[str]]
        """
        If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        """
        context_root: NotRequired[pulumi.Input[str]]
        """
        The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        """
        landing_page: NotRequired[pulumi.Input[str]]
        """
        The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        """
        permissions: NotRequired[pulumi.Input[str]]
        """
        Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        """
        require_sitewide_authentication: NotRequired[pulumi.Input[bool]]
        """
        Require user authentication to access any resource protected by this enforcement point.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppEnforcementPointResourceArgsDict']]]]
        """
        Array of resource objects
        """
        session_expiry_fixed: NotRequired[pulumi.Input['AppEnforcementPointSessionExpiryFixedArgsDict']]
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        session_expiry_inactivity: NotRequired[pulumi.Input['AppEnforcementPointSessionExpiryInactivityArgsDict']]
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        target: NotRequired[pulumi.Input[str]]
        """
        A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        Can only be set on create. Access Gateway Token.
        """
        use_target_host_header: NotRequired[pulumi.Input[bool]]
        """
        Use the target host header as opposed to the original gateway or upstream host header.
        """
        vhost: NotRequired[pulumi.Input[str]]
        """
        A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
elif False:
    AppEnforcementPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEnforcementPointArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 conditions: Optional[pulumi.Input[str]] = None,
                 context_root: Optional[pulumi.Input[str]] = None,
                 landing_page: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input[str]] = None,
                 require_sitewide_authentication: Optional[pulumi.Input[bool]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['AppEnforcementPointResourceArgs']]]] = None,
                 session_expiry_fixed: Optional[pulumi.Input['AppEnforcementPointSessionExpiryFixedArgs']] = None,
                 session_expiry_inactivity: Optional[pulumi.Input['AppEnforcementPointSessionExpiryInactivityArgs']] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 use_target_host_header: Optional[pulumi.Input[bool]] = None,
                 vhost: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] case_sensitive: The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        :param pulumi.Input[str] conditions: If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        :param pulumi.Input[str] context_root: The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        :param pulumi.Input[str] landing_page: The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        :param pulumi.Input[str] permissions: Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        :param pulumi.Input[bool] require_sitewide_authentication: Require user authentication to access any resource protected by this enforcement point.
        :param pulumi.Input[Sequence[pulumi.Input['AppEnforcementPointResourceArgs']]] resources: Array of resource objects
        :param pulumi.Input['AppEnforcementPointSessionExpiryFixedArgs'] session_expiry_fixed: unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        :param pulumi.Input['AppEnforcementPointSessionExpiryInactivityArgs'] session_expiry_inactivity: unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        :param pulumi.Input[str] target: A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        :param pulumi.Input[str] token: Can only be set on create. Access Gateway Token.
        :param pulumi.Input[bool] use_target_host_header: Use the target host header as opposed to the original gateway or upstream host header.
        :param pulumi.Input[str] vhost: A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if context_root is not None:
            pulumi.set(__self__, "context_root", context_root)
        if landing_page is not None:
            pulumi.set(__self__, "landing_page", landing_page)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if require_sitewide_authentication is not None:
            pulumi.set(__self__, "require_sitewide_authentication", require_sitewide_authentication)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if session_expiry_fixed is not None:
            pulumi.set(__self__, "session_expiry_fixed", session_expiry_fixed)
        if session_expiry_inactivity is not None:
            pulumi.set(__self__, "session_expiry_inactivity", session_expiry_inactivity)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if use_target_host_header is not None:
            pulumi.set(__self__, "use_target_host_header", use_target_host_header)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[str]]:
        """
        If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> Optional[pulumi.Input[str]]:
        """
        The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        """
        return pulumi.get(self, "context_root")

    @context_root.setter
    def context_root(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_root", value)

    @property
    @pulumi.getter(name="landingPage")
    def landing_page(self) -> Optional[pulumi.Input[str]]:
        """
        The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        """
        return pulumi.get(self, "landing_page")

    @landing_page.setter
    def landing_page(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "landing_page", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[str]]:
        """
        Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter(name="requireSitewideAuthentication")
    def require_sitewide_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Require user authentication to access any resource protected by this enforcement point.
        """
        return pulumi.get(self, "require_sitewide_authentication")

    @require_sitewide_authentication.setter
    def require_sitewide_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_sitewide_authentication", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppEnforcementPointResourceArgs']]]]:
        """
        Array of resource objects
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppEnforcementPointResourceArgs']]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="sessionExpiryFixed")
    def session_expiry_fixed(self) -> Optional[pulumi.Input['AppEnforcementPointSessionExpiryFixedArgs']]:
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        return pulumi.get(self, "session_expiry_fixed")

    @session_expiry_fixed.setter
    def session_expiry_fixed(self, value: Optional[pulumi.Input['AppEnforcementPointSessionExpiryFixedArgs']]):
        pulumi.set(self, "session_expiry_fixed", value)

    @property
    @pulumi.getter(name="sessionExpiryInactivity")
    def session_expiry_inactivity(self) -> Optional[pulumi.Input['AppEnforcementPointSessionExpiryInactivityArgs']]:
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        return pulumi.get(self, "session_expiry_inactivity")

    @session_expiry_inactivity.setter
    def session_expiry_inactivity(self, value: Optional[pulumi.Input['AppEnforcementPointSessionExpiryInactivityArgs']]):
        pulumi.set(self, "session_expiry_inactivity", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Can only be set on create. Access Gateway Token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="useTargetHostHeader")
    def use_target_host_header(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the target host header as opposed to the original gateway or upstream host header.
        """
        return pulumi.get(self, "use_target_host_header")

    @use_target_host_header.setter
    def use_target_host_header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_target_host_header", value)

    @property
    @pulumi.getter
    def vhost(self) -> Optional[pulumi.Input[str]]:
        """
        A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class AppEnforcementPointResourceArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[str]]
        """
        required if permission == "conditions"
        """
        is_path_regex: NotRequired[pulumi.Input[bool]]
        path: NotRequired[pulumi.Input[str]]
        permission: NotRequired[pulumi.Input[str]]
        require_auth: NotRequired[pulumi.Input[bool]]
elif False:
    AppEnforcementPointResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEnforcementPointResourceArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[str]] = None,
                 is_path_regex: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 permission: Optional[pulumi.Input[str]] = None,
                 require_auth: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] conditions: required if permission == "conditions"
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if is_path_regex is not None:
            pulumi.set(__self__, "is_path_regex", is_path_regex)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if permission is not None:
            pulumi.set(__self__, "permission", permission)
        if require_auth is not None:
            pulumi.set(__self__, "require_auth", require_auth)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[str]]:
        """
        required if permission == "conditions"
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="isPathRegex")
    def is_path_regex(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_path_regex")

    @is_path_regex.setter
    def is_path_regex(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_path_regex", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def permission(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="requireAuth")
    def require_auth(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "require_auth")

    @require_auth.setter
    def require_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_auth", value)


if not MYPY:
    class AppEnforcementPointSessionExpiryFixedArgsDict(TypedDict):
        unit: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[int]]
elif False:
    AppEnforcementPointSessionExpiryFixedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEnforcementPointSessionExpiryFixedArgs:
    def __init__(__self__, *,
                 unit: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppEnforcementPointSessionExpiryInactivityArgsDict(TypedDict):
        unit: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[int]]
elif False:
    AppEnforcementPointSessionExpiryInactivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEnforcementPointSessionExpiryInactivityArgs:
    def __init__(__self__, *,
                 unit: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppParametersArgsDict(TypedDict):
        groups: NotRequired[pulumi.Input['AppParametersGroupsArgsDict']]
elif False:
    AppParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppParametersArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input['AppParametersGroupsArgs']] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['AppParametersGroupsArgs']]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['AppParametersGroupsArgs']]):
        pulumi.set(self, "groups", value)


if not MYPY:
    class AppParametersGroupsArgsDict(TypedDict):
        attributes_transformations: NotRequired[pulumi.Input[str]]
        default_values: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[int]]
        label: NotRequired[pulumi.Input[str]]
        provisioned_entitlements: NotRequired[pulumi.Input[bool]]
        skip_if_blank: NotRequired[pulumi.Input[bool]]
        user_attribute_macros: NotRequired[pulumi.Input[str]]
        user_attribute_mappings: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[str]]
elif False:
    AppParametersGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppParametersGroupsArgs:
    def __init__(__self__, *,
                 attributes_transformations: Optional[pulumi.Input[str]] = None,
                 default_values: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 provisioned_entitlements: Optional[pulumi.Input[bool]] = None,
                 skip_if_blank: Optional[pulumi.Input[bool]] = None,
                 user_attribute_macros: Optional[pulumi.Input[str]] = None,
                 user_attribute_mappings: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[str]] = None):
        if attributes_transformations is not None:
            pulumi.set(__self__, "attributes_transformations", attributes_transformations)
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if provisioned_entitlements is not None:
            pulumi.set(__self__, "provisioned_entitlements", provisioned_entitlements)
        if skip_if_blank is not None:
            pulumi.set(__self__, "skip_if_blank", skip_if_blank)
        if user_attribute_macros is not None:
            pulumi.set(__self__, "user_attribute_macros", user_attribute_macros)
        if user_attribute_mappings is not None:
            pulumi.set(__self__, "user_attribute_mappings", user_attribute_mappings)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="attributesTransformations")
    def attributes_transformations(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attributes_transformations")

    @attributes_transformations.setter
    def attributes_transformations(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attributes_transformations", value)

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_values")

    @default_values.setter
    def default_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_values", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="provisionedEntitlements")
    def provisioned_entitlements(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "provisioned_entitlements")

    @provisioned_entitlements.setter
    def provisioned_entitlements(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provisioned_entitlements", value)

    @property
    @pulumi.getter(name="skipIfBlank")
    def skip_if_blank(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "skip_if_blank")

    @skip_if_blank.setter
    def skip_if_blank(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_if_blank", value)

    @property
    @pulumi.getter(name="userAttributeMacros")
    def user_attribute_macros(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_attribute_macros")

    @user_attribute_macros.setter
    def user_attribute_macros(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_attribute_macros", value)

    @property
    @pulumi.getter(name="userAttributeMappings")
    def user_attribute_mappings(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_attribute_mappings")

    @user_attribute_mappings.setter
    def user_attribute_mappings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_attribute_mappings", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AppProvisioningArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    AppProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppProvisioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class AppSsoArgsDict(TypedDict):
        acs_url: NotRequired[pulumi.Input[str]]
        """
        App Name.	This is only returned after Creating a SAML App.
        """
        certificate: NotRequired[pulumi.Input['AppSsoCertificateArgsDict']]
        """
        The certificate used for signing.	This is only returned after Creating a SAML App.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        OpenId Connet Client Secret
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        Issuer of app.	This is only returned after Creating a SAML App.
        """
        metadata_url: NotRequired[pulumi.Input[str]]
        """
        ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
elif False:
    AppSsoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSsoArgs:
    def __init__(__self__, *,
                 acs_url: Optional[pulumi.Input[str]] = None,
                 certificate: Optional[pulumi.Input['AppSsoCertificateArgs']] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 metadata_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] acs_url: App Name.	This is only returned after Creating a SAML App.
        :param pulumi.Input['AppSsoCertificateArgs'] certificate: The certificate used for signing.	This is only returned after Creating a SAML App.
        :param pulumi.Input[str] client_id: The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        :param pulumi.Input[str] client_secret: OpenId Connet Client Secret
        :param pulumi.Input[str] issuer: Issuer of app.	This is only returned after Creating a SAML App.
        :param pulumi.Input[str] metadata_url: ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
        if acs_url is not None:
            pulumi.set(__self__, "acs_url", acs_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if metadata_url is not None:
            pulumi.set(__self__, "metadata_url", metadata_url)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> Optional[pulumi.Input[str]]:
        """
        App Name.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "acs_url")

    @acs_url.setter
    def acs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acs_url", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AppSsoCertificateArgs']]:
        """
        The certificate used for signing.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AppSsoCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        OpenId Connet Client Secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Issuer of app.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "metadata_url")

    @metadata_url.setter
    def metadata_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_url", value)


if not MYPY:
    class AppSsoCertificateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    AppSsoCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSsoCertificateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AuthServersConfigurationArgsDict(TypedDict):
        audiences: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of API endpoints that will be returned in Access Tokens.
        """
        resource_identifier: pulumi.Input[str]
        """
        Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        """
        access_token_expiration_minutes: NotRequired[pulumi.Input[int]]
        """
        The number of minutes until access token expires. There is no maximum expiry limit.
        """
        refresh_token_expiration_minutes: NotRequired[pulumi.Input[int]]
        """
        The number of minutes until refresh token expires. There is no maximum expiry limit.
        """
elif False:
    AuthServersConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthServersConfigurationArgs:
    def __init__(__self__, *,
                 audiences: pulumi.Input[Sequence[pulumi.Input[str]]],
                 resource_identifier: pulumi.Input[str],
                 access_token_expiration_minutes: Optional[pulumi.Input[int]] = None,
                 refresh_token_expiration_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] audiences: List of API endpoints that will be returned in Access Tokens.
        :param pulumi.Input[str] resource_identifier: Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        :param pulumi.Input[int] access_token_expiration_minutes: The number of minutes until access token expires. There is no maximum expiry limit.
        :param pulumi.Input[int] refresh_token_expiration_minutes: The number of minutes until refresh token expires. There is no maximum expiry limit.
        """
        pulumi.set(__self__, "audiences", audiences)
        pulumi.set(__self__, "resource_identifier", resource_identifier)
        if access_token_expiration_minutes is not None:
            pulumi.set(__self__, "access_token_expiration_minutes", access_token_expiration_minutes)
        if refresh_token_expiration_minutes is not None:
            pulumi.set(__self__, "refresh_token_expiration_minutes", refresh_token_expiration_minutes)

    @property
    @pulumi.getter
    def audiences(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of API endpoints that will be returned in Access Tokens.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "audiences", value)

    @property
    @pulumi.getter(name="resourceIdentifier")
    def resource_identifier(self) -> pulumi.Input[str]:
        """
        Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        """
        return pulumi.get(self, "resource_identifier")

    @resource_identifier.setter
    def resource_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_identifier", value)

    @property
    @pulumi.getter(name="accessTokenExpirationMinutes")
    def access_token_expiration_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes until access token expires. There is no maximum expiry limit.
        """
        return pulumi.get(self, "access_token_expiration_minutes")

    @access_token_expiration_minutes.setter
    def access_token_expiration_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "access_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="refreshTokenExpirationMinutes")
    def refresh_token_expiration_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes until refresh token expires. There is no maximum expiry limit.
        """
        return pulumi.get(self, "refresh_token_expiration_minutes")

    @refresh_token_expiration_minutes.setter
    def refresh_token_expiration_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_token_expiration_minutes", value)


if not MYPY:
    class PrivilegesPrivilegeArgsDict(TypedDict):
        statements: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrivilegesPrivilegeStatementArgsDict']]]]
        version: NotRequired[pulumi.Input[str]]
elif False:
    PrivilegesPrivilegeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivilegesPrivilegeArgs:
    def __init__(__self__, *,
                 statements: Optional[pulumi.Input[Sequence[pulumi.Input['PrivilegesPrivilegeStatementArgs']]]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        if statements is not None:
            pulumi.set(__self__, "statements", statements)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def statements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrivilegesPrivilegeStatementArgs']]]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrivilegesPrivilegeStatementArgs']]]]):
        pulumi.set(self, "statements", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PrivilegesPrivilegeStatementArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
        e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        """
        effect: pulumi.Input[str]
        """
        Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        """
        scopes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Target the privileged action against specific resources with the scope.
        The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
        e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
        The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
        The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
elif False:
    PrivilegesPrivilegeStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivilegesPrivilegeStatementArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 effect: pulumi.Input[str],
                 scopes: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
               e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        :param pulumi.Input[str] effect: Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: Target the privileged action against specific resources with the scope.
               The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
               e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
               The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
               The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
        e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Target the privileged action against specific resources with the scope.
        The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
        e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
        The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
        The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class ProviderEndpointArgsDict(TypedDict):
        apps: NotRequired[pulumi.Input[str]]
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        apps_rules: NotRequired[pulumi.Input[str]]
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        auth_servers: NotRequired[pulumi.Input[str]]
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        privileges: NotRequired[pulumi.Input[str]]
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        risk_rules: NotRequired[pulumi.Input[str]]
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        roles: NotRequired[pulumi.Input[str]]
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        users: NotRequired[pulumi.Input[str]]
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        users_v1: NotRequired[pulumi.Input[str]]
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
elif False:
    ProviderEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderEndpointArgs:
    def __init__(__self__, *,
                 apps: Optional[pulumi.Input[str]] = None,
                 apps_rules: Optional[pulumi.Input[str]] = None,
                 auth_servers: Optional[pulumi.Input[str]] = None,
                 privileges: Optional[pulumi.Input[str]] = None,
                 risk_rules: Optional[pulumi.Input[str]] = None,
                 roles: Optional[pulumi.Input[str]] = None,
                 users: Optional[pulumi.Input[str]] = None,
                 users_v1: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apps: Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        :param pulumi.Input[str] apps_rules: Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        :param pulumi.Input[str] auth_servers: Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        :param pulumi.Input[str] privileges: Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        :param pulumi.Input[str] risk_rules: Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        :param pulumi.Input[str] roles: Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        :param pulumi.Input[str] users: Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        :param pulumi.Input[str] users_v1: Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if apps_rules is not None:
            pulumi.set(__self__, "apps_rules", apps_rules)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if privileges is not None:
            pulumi.set(__self__, "privileges", privileges)
        if risk_rules is not None:
            pulumi.set(__self__, "risk_rules", risk_rules)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if users_v1 is not None:
            pulumi.set(__self__, "users_v1", users_v1)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter(name="appsRules")
    def apps_rules(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        return pulumi.get(self, "apps_rules")

    @apps_rules.setter
    def apps_rules(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apps_rules", value)

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        return pulumi.get(self, "auth_servers")

    @auth_servers.setter
    def auth_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_servers", value)

    @property
    @pulumi.getter
    def privileges(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "privileges", value)

    @property
    @pulumi.getter(name="riskRules")
    def risk_rules(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        return pulumi.get(self, "risk_rules")

    @risk_rules.setter
    def risk_rules(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_rules", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="usersV1")
    def users_v1(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to override the resource endpoint URL (the default one or the one constructed from the `region`).
        """
        return pulumi.get(self, "users_v1")

    @users_v1.setter
    def users_v1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "users_v1", value)


if not MYPY:
    class RiskRulesSourceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        A unique id that represents the source of the event.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the source
        """
elif False:
    RiskRulesSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskRulesSourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: A unique id that represents the source of the event.
        :param pulumi.Input[str] name: The name of the source
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique id that represents the source of the event.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the source
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetAppsConfigurationArgsDict(TypedDict):
        access_token_expiration_minutes: int
        """
        OIDC Apps only Number of minutes the refresh token will be valid for.
        """
        login_url: str
        """
        OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        """
        oidc_api_version: str
        oidc_application_type: int
        """
        OIDC Apps Only
          - 0: Web
          - 1: Native/Mobile
        """
        oidc_encryption_key: str
        """
        OIDC Apps only
        """
        post_logout_redirect_uri: str
        """
        OIDC Apps only
        """
        redirect_uri: str
        """
        OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        """
        refresh_token_expiration_minutes: int
        """
        Number of minutes the refresh token will be valid for.
        """
        token_endpoint_auth_method: int
        """
        OIDC Apps only
         - 0: Basic
         - 1: POST
         - 2: None / PKCE
        """
elif False:
    GetAppsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsConfigurationArgs:
    def __init__(__self__, *,
                 access_token_expiration_minutes: int,
                 login_url: str,
                 oidc_api_version: str,
                 oidc_application_type: int,
                 oidc_encryption_key: str,
                 post_logout_redirect_uri: str,
                 redirect_uri: str,
                 refresh_token_expiration_minutes: int,
                 token_endpoint_auth_method: int):
        """
        :param int access_token_expiration_minutes: OIDC Apps only Number of minutes the refresh token will be valid for.
        :param str login_url: OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        :param int oidc_application_type: OIDC Apps Only
                 - 0: Web
                 - 1: Native/Mobile
        :param str oidc_encryption_key: OIDC Apps only
        :param str post_logout_redirect_uri: OIDC Apps only
        :param str redirect_uri: OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        :param int refresh_token_expiration_minutes: Number of minutes the refresh token will be valid for.
        :param int token_endpoint_auth_method: OIDC Apps only
                - 0: Basic
                - 1: POST
                - 2: None / PKCE
        """
        pulumi.set(__self__, "access_token_expiration_minutes", access_token_expiration_minutes)
        pulumi.set(__self__, "login_url", login_url)
        pulumi.set(__self__, "oidc_api_version", oidc_api_version)
        pulumi.set(__self__, "oidc_application_type", oidc_application_type)
        pulumi.set(__self__, "oidc_encryption_key", oidc_encryption_key)
        pulumi.set(__self__, "post_logout_redirect_uri", post_logout_redirect_uri)
        pulumi.set(__self__, "redirect_uri", redirect_uri)
        pulumi.set(__self__, "refresh_token_expiration_minutes", refresh_token_expiration_minutes)
        pulumi.set(__self__, "token_endpoint_auth_method", token_endpoint_auth_method)

    @property
    @pulumi.getter(name="accessTokenExpirationMinutes")
    def access_token_expiration_minutes(self) -> int:
        """
        OIDC Apps only Number of minutes the refresh token will be valid for.
        """
        return pulumi.get(self, "access_token_expiration_minutes")

    @access_token_expiration_minutes.setter
    def access_token_expiration_minutes(self, value: int):
        pulumi.set(self, "access_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="loginUrl")
    def login_url(self) -> str:
        """
        OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        """
        return pulumi.get(self, "login_url")

    @login_url.setter
    def login_url(self, value: str):
        pulumi.set(self, "login_url", value)

    @property
    @pulumi.getter(name="oidcApiVersion")
    def oidc_api_version(self) -> str:
        return pulumi.get(self, "oidc_api_version")

    @oidc_api_version.setter
    def oidc_api_version(self, value: str):
        pulumi.set(self, "oidc_api_version", value)

    @property
    @pulumi.getter(name="oidcApplicationType")
    def oidc_application_type(self) -> int:
        """
        OIDC Apps Only
          - 0: Web
          - 1: Native/Mobile
        """
        return pulumi.get(self, "oidc_application_type")

    @oidc_application_type.setter
    def oidc_application_type(self, value: int):
        pulumi.set(self, "oidc_application_type", value)

    @property
    @pulumi.getter(name="oidcEncryptionKey")
    def oidc_encryption_key(self) -> str:
        """
        OIDC Apps only
        """
        return pulumi.get(self, "oidc_encryption_key")

    @oidc_encryption_key.setter
    def oidc_encryption_key(self, value: str):
        pulumi.set(self, "oidc_encryption_key", value)

    @property
    @pulumi.getter(name="postLogoutRedirectUri")
    def post_logout_redirect_uri(self) -> str:
        """
        OIDC Apps only
        """
        return pulumi.get(self, "post_logout_redirect_uri")

    @post_logout_redirect_uri.setter
    def post_logout_redirect_uri(self, value: str):
        pulumi.set(self, "post_logout_redirect_uri", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> str:
        """
        OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: str):
        pulumi.set(self, "redirect_uri", value)

    @property
    @pulumi.getter(name="refreshTokenExpirationMinutes")
    def refresh_token_expiration_minutes(self) -> int:
        """
        Number of minutes the refresh token will be valid for.
        """
        return pulumi.get(self, "refresh_token_expiration_minutes")

    @refresh_token_expiration_minutes.setter
    def refresh_token_expiration_minutes(self, value: int):
        pulumi.set(self, "refresh_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="tokenEndpointAuthMethod")
    def token_endpoint_auth_method(self) -> int:
        """
        OIDC Apps only
         - 0: Basic
         - 1: POST
         - 2: None / PKCE
        """
        return pulumi.get(self, "token_endpoint_auth_method")

    @token_endpoint_auth_method.setter
    def token_endpoint_auth_method(self, value: int):
        pulumi.set(self, "token_endpoint_auth_method", value)


if not MYPY:
    class GetAppsEnforcementPointArgsDict(TypedDict):
        case_sensitive: bool
        """
        The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        """
        conditions: str
        """
        If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        """
        context_root: str
        """
        The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        """
        landing_page: str
        """
        The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        """
        permissions: str
        """
        Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        """
        require_sitewide_authentication: bool
        """
        Require user authentication to access any resource protected by this enforcement point.
        """
        resources: Sequence['GetAppsEnforcementPointResourceArgsDict']
        """
        Array of resource objects
        """
        session_expiry_fixed: 'GetAppsEnforcementPointSessionExpiryFixedArgsDict'
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        session_expiry_inactivity: 'GetAppsEnforcementPointSessionExpiryInactivityArgsDict'
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        target: str
        """
        A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        """
        token: str
        """
        Can only be set on create. Access Gateway Token.
        """
        use_target_host_header: bool
        """
        Use the target host header as opposed to the original gateway or upstream host header.
        """
        vhost: str
        """
        A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
elif False:
    GetAppsEnforcementPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsEnforcementPointArgs:
    def __init__(__self__, *,
                 case_sensitive: bool,
                 conditions: str,
                 context_root: str,
                 landing_page: str,
                 permissions: str,
                 require_sitewide_authentication: bool,
                 resources: Sequence['GetAppsEnforcementPointResourceArgs'],
                 session_expiry_fixed: 'GetAppsEnforcementPointSessionExpiryFixedArgs',
                 session_expiry_inactivity: 'GetAppsEnforcementPointSessionExpiryInactivityArgs',
                 target: str,
                 token: str,
                 use_target_host_header: bool,
                 vhost: str):
        """
        :param bool case_sensitive: The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        :param str conditions: If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        :param str context_root: The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        :param str landing_page: The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        :param str permissions: Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        :param bool require_sitewide_authentication: Require user authentication to access any resource protected by this enforcement point.
        :param Sequence['GetAppsEnforcementPointResourceArgs'] resources: Array of resource objects
        :param 'GetAppsEnforcementPointSessionExpiryFixedArgs' session_expiry_fixed: unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        :param 'GetAppsEnforcementPointSessionExpiryInactivityArgs' session_expiry_inactivity: unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        :param str target: A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        :param str token: Can only be set on create. Access Gateway Token.
        :param bool use_target_host_header: Use the target host header as opposed to the original gateway or upstream host header.
        :param str vhost: A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "context_root", context_root)
        pulumi.set(__self__, "landing_page", landing_page)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "require_sitewide_authentication", require_sitewide_authentication)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "session_expiry_fixed", session_expiry_fixed)
        pulumi.set(__self__, "session_expiry_inactivity", session_expiry_inactivity)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "use_target_host_header", use_target_host_header)
        pulumi.set(__self__, "vhost", vhost)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> bool:
        """
        The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: bool):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter
    def conditions(self) -> str:
        """
        If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: str):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> str:
        """
        The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        """
        return pulumi.get(self, "context_root")

    @context_root.setter
    def context_root(self, value: str):
        pulumi.set(self, "context_root", value)

    @property
    @pulumi.getter(name="landingPage")
    def landing_page(self) -> str:
        """
        The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        """
        return pulumi.get(self, "landing_page")

    @landing_page.setter
    def landing_page(self, value: str):
        pulumi.set(self, "landing_page", value)

    @property
    @pulumi.getter
    def permissions(self) -> str:
        """
        Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: str):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter(name="requireSitewideAuthentication")
    def require_sitewide_authentication(self) -> bool:
        """
        Require user authentication to access any resource protected by this enforcement point.
        """
        return pulumi.get(self, "require_sitewide_authentication")

    @require_sitewide_authentication.setter
    def require_sitewide_authentication(self, value: bool):
        pulumi.set(self, "require_sitewide_authentication", value)

    @property
    @pulumi.getter
    def resources(self) -> Sequence['GetAppsEnforcementPointResourceArgs']:
        """
        Array of resource objects
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Sequence['GetAppsEnforcementPointResourceArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="sessionExpiryFixed")
    def session_expiry_fixed(self) -> 'GetAppsEnforcementPointSessionExpiryFixedArgs':
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        return pulumi.get(self, "session_expiry_fixed")

    @session_expiry_fixed.setter
    def session_expiry_fixed(self, value: 'GetAppsEnforcementPointSessionExpiryFixedArgs'):
        pulumi.set(self, "session_expiry_fixed", value)

    @property
    @pulumi.getter(name="sessionExpiryInactivity")
    def session_expiry_inactivity(self) -> 'GetAppsEnforcementPointSessionExpiryInactivityArgs':
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        return pulumi.get(self, "session_expiry_inactivity")

    @session_expiry_inactivity.setter
    def session_expiry_inactivity(self, value: 'GetAppsEnforcementPointSessionExpiryInactivityArgs'):
        pulumi.set(self, "session_expiry_inactivity", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: str):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Can only be set on create. Access Gateway Token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: str):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="useTargetHostHeader")
    def use_target_host_header(self) -> bool:
        """
        Use the target host header as opposed to the original gateway or upstream host header.
        """
        return pulumi.get(self, "use_target_host_header")

    @use_target_host_header.setter
    def use_target_host_header(self, value: bool):
        pulumi.set(self, "use_target_host_header", value)

    @property
    @pulumi.getter
    def vhost(self) -> str:
        """
        A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: str):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class GetAppsEnforcementPointResourceArgsDict(TypedDict):
        conditions: str
        """
        required if permission == "conditions"
        """
        is_path_regex: bool
        path: str
        permission: str
        require_auth: bool
elif False:
    GetAppsEnforcementPointResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsEnforcementPointResourceArgs:
    def __init__(__self__, *,
                 conditions: str,
                 is_path_regex: bool,
                 path: str,
                 permission: str,
                 require_auth: bool):
        """
        :param str conditions: required if permission == "conditions"
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "is_path_regex", is_path_regex)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "require_auth", require_auth)

    @property
    @pulumi.getter
    def conditions(self) -> str:
        """
        required if permission == "conditions"
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: str):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="isPathRegex")
    def is_path_regex(self) -> bool:
        return pulumi.get(self, "is_path_regex")

    @is_path_regex.setter
    def is_path_regex(self, value: bool):
        pulumi.set(self, "is_path_regex", value)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def permission(self) -> str:
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: str):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="requireAuth")
    def require_auth(self) -> bool:
        return pulumi.get(self, "require_auth")

    @require_auth.setter
    def require_auth(self, value: bool):
        pulumi.set(self, "require_auth", value)


if not MYPY:
    class GetAppsEnforcementPointSessionExpiryFixedArgsDict(TypedDict):
        unit: int
        value: int
elif False:
    GetAppsEnforcementPointSessionExpiryFixedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsEnforcementPointSessionExpiryFixedArgs:
    def __init__(__self__, *,
                 unit: int,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> int:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: int):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAppsEnforcementPointSessionExpiryInactivityArgsDict(TypedDict):
        unit: int
        value: int
elif False:
    GetAppsEnforcementPointSessionExpiryInactivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsEnforcementPointSessionExpiryInactivityArgs:
    def __init__(__self__, *,
                 unit: int,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> int:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: int):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAppsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetAppsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetAppsParametersArgsDict(TypedDict):
        groups: 'GetAppsParametersGroupsArgsDict'
elif False:
    GetAppsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsParametersArgs:
    def __init__(__self__, *,
                 groups: 'GetAppsParametersGroupsArgs'):
        pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def groups(self) -> 'GetAppsParametersGroupsArgs':
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: 'GetAppsParametersGroupsArgs'):
        pulumi.set(self, "groups", value)


if not MYPY:
    class GetAppsParametersGroupsArgsDict(TypedDict):
        attributes_transformations: str
        default_values: str
        id: int
        label: str
        provisioned_entitlements: bool
        skip_if_blank: bool
        user_attribute_macros: str
        user_attribute_mappings: str
        values: str
elif False:
    GetAppsParametersGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsParametersGroupsArgs:
    def __init__(__self__, *,
                 attributes_transformations: str,
                 default_values: str,
                 id: int,
                 label: str,
                 provisioned_entitlements: bool,
                 skip_if_blank: bool,
                 user_attribute_macros: str,
                 user_attribute_mappings: str,
                 values: str):
        pulumi.set(__self__, "attributes_transformations", attributes_transformations)
        pulumi.set(__self__, "default_values", default_values)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "provisioned_entitlements", provisioned_entitlements)
        pulumi.set(__self__, "skip_if_blank", skip_if_blank)
        pulumi.set(__self__, "user_attribute_macros", user_attribute_macros)
        pulumi.set(__self__, "user_attribute_mappings", user_attribute_mappings)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="attributesTransformations")
    def attributes_transformations(self) -> str:
        return pulumi.get(self, "attributes_transformations")

    @attributes_transformations.setter
    def attributes_transformations(self, value: str):
        pulumi.set(self, "attributes_transformations", value)

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> str:
        return pulumi.get(self, "default_values")

    @default_values.setter
    def default_values(self, value: str):
        pulumi.set(self, "default_values", value)

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: int):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: str):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="provisionedEntitlements")
    def provisioned_entitlements(self) -> bool:
        return pulumi.get(self, "provisioned_entitlements")

    @provisioned_entitlements.setter
    def provisioned_entitlements(self, value: bool):
        pulumi.set(self, "provisioned_entitlements", value)

    @property
    @pulumi.getter(name="skipIfBlank")
    def skip_if_blank(self) -> bool:
        return pulumi.get(self, "skip_if_blank")

    @skip_if_blank.setter
    def skip_if_blank(self, value: bool):
        pulumi.set(self, "skip_if_blank", value)

    @property
    @pulumi.getter(name="userAttributeMacros")
    def user_attribute_macros(self) -> str:
        return pulumi.get(self, "user_attribute_macros")

    @user_attribute_macros.setter
    def user_attribute_macros(self, value: str):
        pulumi.set(self, "user_attribute_macros", value)

    @property
    @pulumi.getter(name="userAttributeMappings")
    def user_attribute_mappings(self) -> str:
        return pulumi.get(self, "user_attribute_mappings")

    @user_attribute_mappings.setter
    def user_attribute_mappings(self, value: str):
        pulumi.set(self, "user_attribute_mappings", value)

    @property
    @pulumi.getter
    def values(self) -> str:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: str):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetAppsProvisioningArgsDict(TypedDict):
        enabled: bool
        status: str
elif False:
    GetAppsProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsProvisioningArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 status: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetAppsSsoArgsDict(TypedDict):
        acs_url: str
        """
        App Name.	This is only returned after Creating a SAML App.
        """
        certificate: 'GetAppsSsoCertificateArgsDict'
        """
        The certificate used for signing.	This is only returned after Creating a SAML App.
        """
        client_id: str
        """
        The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        """
        client_secret: str
        """
        OpenId Connet Client Secret
        """
        issuer: str
        """
        Issuer of app.	This is only returned after Creating a SAML App.
        """
        metadata_url: str
        """
        ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
elif False:
    GetAppsSsoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsSsoArgs:
    def __init__(__self__, *,
                 acs_url: str,
                 certificate: 'GetAppsSsoCertificateArgs',
                 client_id: str,
                 client_secret: str,
                 issuer: str,
                 metadata_url: str):
        """
        :param str acs_url: App Name.	This is only returned after Creating a SAML App.
        :param 'GetAppsSsoCertificateArgs' certificate: The certificate used for signing.	This is only returned after Creating a SAML App.
        :param str client_id: The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        :param str client_secret: OpenId Connet Client Secret
        :param str issuer: Issuer of app.	This is only returned after Creating a SAML App.
        :param str metadata_url: ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
        pulumi.set(__self__, "acs_url", acs_url)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "metadata_url", metadata_url)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> str:
        """
        App Name.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "acs_url")

    @acs_url.setter
    def acs_url(self, value: str):
        pulumi.set(self, "acs_url", value)

    @property
    @pulumi.getter
    def certificate(self) -> 'GetAppsSsoCertificateArgs':
        """
        The certificate used for signing.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: 'GetAppsSsoCertificateArgs'):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: str):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        OpenId Connet Client Secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: str):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        Issuer of app.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: str):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> str:
        """
        ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "metadata_url")

    @metadata_url.setter
    def metadata_url(self, value: str):
        pulumi.set(self, "metadata_url", value)


if not MYPY:
    class GetAppsSsoCertificateArgsDict(TypedDict):
        id: int
        name: str
        value: str
elif False:
    GetAppsSsoCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppsSsoCertificateArgs:
    def __init__(__self__, *,
                 id: int,
                 name: str,
                 value: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: int):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAuthServersClaimsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetAuthServersClaimsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuthServersClaimsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetAuthServersConfigurationArgsDict(TypedDict):
        access_token_expiration_minutes: int
        """
        The number of minutes until access token expires. There is no maximum expiry limit.
        """
        audiences: Sequence[str]
        """
        List of API endpoints that will be returned in Access Tokens.
        """
        refresh_token_expiration_minutes: int
        """
        The number of minutes until refresh token expires. There is no maximum expiry limit.
        """
        resource_identifier: str
        """
        Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        """
elif False:
    GetAuthServersConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuthServersConfigurationArgs:
    def __init__(__self__, *,
                 access_token_expiration_minutes: int,
                 audiences: Sequence[str],
                 refresh_token_expiration_minutes: int,
                 resource_identifier: str):
        """
        :param int access_token_expiration_minutes: The number of minutes until access token expires. There is no maximum expiry limit.
        :param Sequence[str] audiences: List of API endpoints that will be returned in Access Tokens.
        :param int refresh_token_expiration_minutes: The number of minutes until refresh token expires. There is no maximum expiry limit.
        :param str resource_identifier: Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        """
        pulumi.set(__self__, "access_token_expiration_minutes", access_token_expiration_minutes)
        pulumi.set(__self__, "audiences", audiences)
        pulumi.set(__self__, "refresh_token_expiration_minutes", refresh_token_expiration_minutes)
        pulumi.set(__self__, "resource_identifier", resource_identifier)

    @property
    @pulumi.getter(name="accessTokenExpirationMinutes")
    def access_token_expiration_minutes(self) -> int:
        """
        The number of minutes until access token expires. There is no maximum expiry limit.
        """
        return pulumi.get(self, "access_token_expiration_minutes")

    @access_token_expiration_minutes.setter
    def access_token_expiration_minutes(self, value: int):
        pulumi.set(self, "access_token_expiration_minutes", value)

    @property
    @pulumi.getter
    def audiences(self) -> Sequence[str]:
        """
        List of API endpoints that will be returned in Access Tokens.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Sequence[str]):
        pulumi.set(self, "audiences", value)

    @property
    @pulumi.getter(name="refreshTokenExpirationMinutes")
    def refresh_token_expiration_minutes(self) -> int:
        """
        The number of minutes until refresh token expires. There is no maximum expiry limit.
        """
        return pulumi.get(self, "refresh_token_expiration_minutes")

    @refresh_token_expiration_minutes.setter
    def refresh_token_expiration_minutes(self, value: int):
        pulumi.set(self, "refresh_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="resourceIdentifier")
    def resource_identifier(self) -> str:
        """
        Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        """
        return pulumi.get(self, "resource_identifier")

    @resource_identifier.setter
    def resource_identifier(self, value: str):
        pulumi.set(self, "resource_identifier", value)


if not MYPY:
    class GetAuthServersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetAuthServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuthServersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetAuthServersInstanceConfigurationArgsDict(TypedDict):
        access_token_expiration_minutes: int
        """
        The number of minutes until access token expires. There is no maximum expiry limit.
        """
        audiences: Sequence[str]
        """
        List of API endpoints that will be returned in Access Tokens.
        """
        refresh_token_expiration_minutes: int
        """
        The number of minutes until refresh token expires. There is no maximum expiry limit.
        """
        resource_identifier: str
        """
        Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        """
elif False:
    GetAuthServersInstanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuthServersInstanceConfigurationArgs:
    def __init__(__self__, *,
                 access_token_expiration_minutes: int,
                 audiences: Sequence[str],
                 refresh_token_expiration_minutes: int,
                 resource_identifier: str):
        """
        :param int access_token_expiration_minutes: The number of minutes until access token expires. There is no maximum expiry limit.
        :param Sequence[str] audiences: List of API endpoints that will be returned in Access Tokens.
        :param int refresh_token_expiration_minutes: The number of minutes until refresh token expires. There is no maximum expiry limit.
        :param str resource_identifier: Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        """
        pulumi.set(__self__, "access_token_expiration_minutes", access_token_expiration_minutes)
        pulumi.set(__self__, "audiences", audiences)
        pulumi.set(__self__, "refresh_token_expiration_minutes", refresh_token_expiration_minutes)
        pulumi.set(__self__, "resource_identifier", resource_identifier)

    @property
    @pulumi.getter(name="accessTokenExpirationMinutes")
    def access_token_expiration_minutes(self) -> int:
        """
        The number of minutes until access token expires. There is no maximum expiry limit.
        """
        return pulumi.get(self, "access_token_expiration_minutes")

    @access_token_expiration_minutes.setter
    def access_token_expiration_minutes(self, value: int):
        pulumi.set(self, "access_token_expiration_minutes", value)

    @property
    @pulumi.getter
    def audiences(self) -> Sequence[str]:
        """
        List of API endpoints that will be returned in Access Tokens.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Sequence[str]):
        pulumi.set(self, "audiences", value)

    @property
    @pulumi.getter(name="refreshTokenExpirationMinutes")
    def refresh_token_expiration_minutes(self) -> int:
        """
        The number of minutes until refresh token expires. There is no maximum expiry limit.
        """
        return pulumi.get(self, "refresh_token_expiration_minutes")

    @refresh_token_expiration_minutes.setter
    def refresh_token_expiration_minutes(self, value: int):
        pulumi.set(self, "refresh_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="resourceIdentifier")
    def resource_identifier(self) -> str:
        """
        Unique identifier for the API that the Authorization Server will issue Access Tokens for.
        """
        return pulumi.get(self, "resource_identifier")

    @resource_identifier.setter
    def resource_identifier(self, value: str):
        pulumi.set(self, "resource_identifier", value)


if not MYPY:
    class GetAuthServersScopesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetAuthServersScopesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAuthServersScopesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetMappingsActionArgsDict(TypedDict):
        action: str
        """
        The action to apply
        """
        values: Sequence[str]
        """
        Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
elif False:
    GetMappingsActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMappingsActionArgs:
    def __init__(__self__, *,
                 action: str,
                 values: Sequence[str]):
        """
        :param str action: The action to apply
        :param Sequence[str] values: Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to apply
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: str):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetMappingsConditionArgsDict(TypedDict):
        operator: str
        """
        A valid operator for the selected condition source
        """
        source: str
        """
        source field to check.
        """
        value: str
        """
        A plain text string or valid value for the selected  condition source
        """
elif False:
    GetMappingsConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMappingsConditionArgs:
    def __init__(__self__, *,
                 operator: str,
                 source: str,
                 value: str):
        """
        :param str operator: A valid operator for the selected condition source
        :param str source: source field to check.
        :param str value: A plain text string or valid value for the selected  condition source
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A valid operator for the selected condition source
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: str):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        source field to check.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: str):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        A plain text string or valid value for the selected  condition source
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetMappingsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetMappingsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMappingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPrivilegesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetPrivilegesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrivilegesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPrivilegesInstancePrivilegeArgsDict(TypedDict):
        statements: Sequence['GetPrivilegesInstancePrivilegeStatementArgsDict']
        version: str
elif False:
    GetPrivilegesInstancePrivilegeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrivilegesInstancePrivilegeArgs:
    def __init__(__self__, *,
                 statements: Sequence['GetPrivilegesInstancePrivilegeStatementArgs'],
                 version: str):
        pulumi.set(__self__, "statements", statements)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['GetPrivilegesInstancePrivilegeStatementArgs']:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: Sequence['GetPrivilegesInstancePrivilegeStatementArgs']):
        pulumi.set(self, "statements", value)

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: str):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetPrivilegesInstancePrivilegeStatementArgsDict(TypedDict):
        actions: Sequence[str]
        """
        An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
        e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        """
        effect: str
        """
        Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        """
        scopes: Sequence[str]
        """
        Target the privileged action against specific resources with the scope.
        The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
        e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
        The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
        The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
elif False:
    GetPrivilegesInstancePrivilegeStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrivilegesInstancePrivilegeStatementArgs:
    def __init__(__self__, *,
                 actions: Sequence[str],
                 effect: str,
                 scopes: Sequence[str]):
        """
        :param Sequence[str] actions: An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
               e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        :param str effect: Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        :param Sequence[str] scopes: Target the privileged action against specific resources with the scope.
               The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
               e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
               The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
               The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
        e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Sequence[str]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: str):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Target the privileged action against specific resources with the scope.
        The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
        e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
        The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
        The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Sequence[str]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class GetPrivilegesPrivilegeArgsDict(TypedDict):
        statements: Sequence['GetPrivilegesPrivilegeStatementArgsDict']
        version: str
elif False:
    GetPrivilegesPrivilegeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrivilegesPrivilegeArgs:
    def __init__(__self__, *,
                 statements: Sequence['GetPrivilegesPrivilegeStatementArgs'],
                 version: str):
        pulumi.set(__self__, "statements", statements)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['GetPrivilegesPrivilegeStatementArgs']:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: Sequence['GetPrivilegesPrivilegeStatementArgs']):
        pulumi.set(self, "statements", value)

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: str):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetPrivilegesPrivilegeStatementArgsDict(TypedDict):
        actions: Sequence[str]
        """
        An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
        e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        """
        effect: str
        """
        Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        """
        scopes: Sequence[str]
        """
        Target the privileged action against specific resources with the scope.
        The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
        e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
        The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
        The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
elif False:
    GetPrivilegesPrivilegeStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPrivilegesPrivilegeStatementArgs:
    def __init__(__self__, *,
                 actions: Sequence[str],
                 effect: str,
                 scopes: Sequence[str]):
        """
        :param Sequence[str] actions: An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
               e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        :param str effect: Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        :param Sequence[str] scopes: Target the privileged action against specific resources with the scope.
               The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
               e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
               The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
               The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class.
        e.g. users:List, where the class is users and the specific action is List. Don’t mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Sequence[str]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Set to “Allow.” By default, all actions are denied, this Statement allows the listed actions to be executed.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: str):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Target the privileged action against specific resources with the scope.
        The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin.
        e.g. apps/1234, where apps is the class and 1234 is the ID of an app.
        The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope.
        The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Sequence[str]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class GetRiskRulesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetRiskRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRiskRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRiskRulesInstanceSourceArgsDict(TypedDict):
        id: str
        """
        A unique id that represents the source of the event.
        """
        name: str
        """
        The name of the source
        """
elif False:
    GetRiskRulesInstanceSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRiskRulesInstanceSourceArgs:
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: A unique id that represents the source of the event.
        :param str name: The name of the source
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A unique id that represents the source of the event.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the source
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetRiskRulesSourceArgsDict(TypedDict):
        id: str
        """
        A unique id that represents the source of the event.
        """
        name: str
        """
        The name of the source
        """
elif False:
    GetRiskRulesSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRiskRulesSourceArgs:
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: A unique id that represents the source of the event.
        :param str name: The name of the source
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A unique id that represents the source of the event.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the source
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


