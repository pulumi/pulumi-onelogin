# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'RulesActionArgs',
    'RulesActionArgsDict',
    'RulesConditionArgs',
    'RulesConditionArgsDict',
    'GetActionsFilterArgs',
    'GetActionsFilterArgsDict',
    'GetActionsValuesFilterArgs',
    'GetActionsValuesFilterArgsDict',
    'GetConditionsFilterArgs',
    'GetConditionsFilterArgsDict',
    'GetConditionsOperatorsFilterArgs',
    'GetConditionsOperatorsFilterArgsDict',
    'GetInstanceConfigurationArgs',
    'GetInstanceConfigurationArgsDict',
    'GetInstanceEnforcementPointArgs',
    'GetInstanceEnforcementPointArgsDict',
    'GetInstanceEnforcementPointResourceArgs',
    'GetInstanceEnforcementPointResourceArgsDict',
    'GetInstanceEnforcementPointSessionExpiryFixedArgs',
    'GetInstanceEnforcementPointSessionExpiryFixedArgsDict',
    'GetInstanceEnforcementPointSessionExpiryInactivityArgs',
    'GetInstanceEnforcementPointSessionExpiryInactivityArgsDict',
    'GetInstanceParametersArgs',
    'GetInstanceParametersArgsDict',
    'GetInstanceParametersGroupsArgs',
    'GetInstanceParametersGroupsArgsDict',
    'GetInstanceProvisioningArgs',
    'GetInstanceProvisioningArgsDict',
    'GetInstanceSsoArgs',
    'GetInstanceSsoArgsDict',
    'GetInstanceSsoCertificateArgs',
    'GetInstanceSsoCertificateArgsDict',
    'GetRulesActionArgs',
    'GetRulesActionArgsDict',
    'GetRulesConditionArgs',
    'GetRulesConditionArgsDict',
    'GetRulesFilterArgs',
    'GetRulesFilterArgsDict',
    'GetRulesInstanceActionArgs',
    'GetRulesInstanceActionArgsDict',
    'GetRulesInstanceConditionArgs',
    'GetRulesInstanceConditionArgsDict',
    'GetUsersFilterArgs',
    'GetUsersFilterArgsDict',
]

MYPY = False

if not MYPY:
    class RulesActionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to apply
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
elif False:
    RulesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesActionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] action: The action to apply
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to apply
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RulesConditionArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[str]]
        """
        A valid operator for the selected condition source
        """
        source: NotRequired[pulumi.Input[str]]
        """
        source field to check.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        A plain text string or valid value for the selected  condition source
        """
elif False:
    RulesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesConditionArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: A valid operator for the selected condition source
        :param pulumi.Input[str] source: source field to check.
        :param pulumi.Input[str] value: A plain text string or valid value for the selected  condition source
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        A valid operator for the selected condition source
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        source field to check.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        A plain text string or valid value for the selected  condition source
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetActionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetActionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetActionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetActionsValuesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetActionsValuesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetActionsValuesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetConditionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetConditionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConditionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetConditionsOperatorsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetConditionsOperatorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConditionsOperatorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetInstanceConfigurationArgsDict(TypedDict):
        access_token_expiration_minutes: int
        """
        OIDC Apps only Number of minutes the refresh token will be valid for.
        """
        login_url: str
        """
        OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        """
        oidc_api_version: str
        oidc_application_type: int
        """
        OIDC Apps Only
          - 0: Web
          - 1: Native/Mobile
        """
        oidc_encryption_key: str
        """
        OIDC Apps only
        """
        post_logout_redirect_uri: str
        """
        OIDC Apps only
        """
        redirect_uri: str
        """
        OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        """
        refresh_token_expiration_minutes: int
        """
        Number of minutes the refresh token will be valid for.
        """
        token_endpoint_auth_method: int
        """
        OIDC Apps only
         - 0: Basic
         - 1: POST
         - 2: None / PKCE
        """
elif False:
    GetInstanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceConfigurationArgs:
    def __init__(__self__, *,
                 access_token_expiration_minutes: int,
                 login_url: str,
                 oidc_api_version: str,
                 oidc_application_type: int,
                 oidc_encryption_key: str,
                 post_logout_redirect_uri: str,
                 redirect_uri: str,
                 refresh_token_expiration_minutes: int,
                 token_endpoint_auth_method: int):
        """
        :param int access_token_expiration_minutes: OIDC Apps only Number of minutes the refresh token will be valid for.
        :param str login_url: OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        :param int oidc_application_type: OIDC Apps Only
                 - 0: Web
                 - 1: Native/Mobile
        :param str oidc_encryption_key: OIDC Apps only
        :param str post_logout_redirect_uri: OIDC Apps only
        :param str redirect_uri: OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        :param int refresh_token_expiration_minutes: Number of minutes the refresh token will be valid for.
        :param int token_endpoint_auth_method: OIDC Apps only
                - 0: Basic
                - 1: POST
                - 2: None / PKCE
        """
        pulumi.set(__self__, "access_token_expiration_minutes", access_token_expiration_minutes)
        pulumi.set(__self__, "login_url", login_url)
        pulumi.set(__self__, "oidc_api_version", oidc_api_version)
        pulumi.set(__self__, "oidc_application_type", oidc_application_type)
        pulumi.set(__self__, "oidc_encryption_key", oidc_encryption_key)
        pulumi.set(__self__, "post_logout_redirect_uri", post_logout_redirect_uri)
        pulumi.set(__self__, "redirect_uri", redirect_uri)
        pulumi.set(__self__, "refresh_token_expiration_minutes", refresh_token_expiration_minutes)
        pulumi.set(__self__, "token_endpoint_auth_method", token_endpoint_auth_method)

    @property
    @pulumi.getter(name="accessTokenExpirationMinutes")
    def access_token_expiration_minutes(self) -> int:
        """
        OIDC Apps only Number of minutes the refresh token will be valid for.
        """
        return pulumi.get(self, "access_token_expiration_minutes")

    @access_token_expiration_minutes.setter
    def access_token_expiration_minutes(self, value: int):
        pulumi.set(self, "access_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="loginUrl")
    def login_url(self) -> str:
        """
        OIDC Apps only The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.
        """
        return pulumi.get(self, "login_url")

    @login_url.setter
    def login_url(self, value: str):
        pulumi.set(self, "login_url", value)

    @property
    @pulumi.getter(name="oidcApiVersion")
    def oidc_api_version(self) -> str:
        return pulumi.get(self, "oidc_api_version")

    @oidc_api_version.setter
    def oidc_api_version(self, value: str):
        pulumi.set(self, "oidc_api_version", value)

    @property
    @pulumi.getter(name="oidcApplicationType")
    def oidc_application_type(self) -> int:
        """
        OIDC Apps Only
          - 0: Web
          - 1: Native/Mobile
        """
        return pulumi.get(self, "oidc_application_type")

    @oidc_application_type.setter
    def oidc_application_type(self, value: int):
        pulumi.set(self, "oidc_application_type", value)

    @property
    @pulumi.getter(name="oidcEncryptionKey")
    def oidc_encryption_key(self) -> str:
        """
        OIDC Apps only
        """
        return pulumi.get(self, "oidc_encryption_key")

    @oidc_encryption_key.setter
    def oidc_encryption_key(self, value: str):
        pulumi.set(self, "oidc_encryption_key", value)

    @property
    @pulumi.getter(name="postLogoutRedirectUri")
    def post_logout_redirect_uri(self) -> str:
        """
        OIDC Apps only
        """
        return pulumi.get(self, "post_logout_redirect_uri")

    @post_logout_redirect_uri.setter
    def post_logout_redirect_uri(self, value: str):
        pulumi.set(self, "post_logout_redirect_uri", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> str:
        """
        OIDC Apps only Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: str):
        pulumi.set(self, "redirect_uri", value)

    @property
    @pulumi.getter(name="refreshTokenExpirationMinutes")
    def refresh_token_expiration_minutes(self) -> int:
        """
        Number of minutes the refresh token will be valid for.
        """
        return pulumi.get(self, "refresh_token_expiration_minutes")

    @refresh_token_expiration_minutes.setter
    def refresh_token_expiration_minutes(self, value: int):
        pulumi.set(self, "refresh_token_expiration_minutes", value)

    @property
    @pulumi.getter(name="tokenEndpointAuthMethod")
    def token_endpoint_auth_method(self) -> int:
        """
        OIDC Apps only
         - 0: Basic
         - 1: POST
         - 2: None / PKCE
        """
        return pulumi.get(self, "token_endpoint_auth_method")

    @token_endpoint_auth_method.setter
    def token_endpoint_auth_method(self, value: int):
        pulumi.set(self, "token_endpoint_auth_method", value)


if not MYPY:
    class GetInstanceEnforcementPointArgsDict(TypedDict):
        case_sensitive: bool
        """
        The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        """
        conditions: str
        """
        If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        """
        context_root: str
        """
        The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        """
        landing_page: str
        """
        The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        """
        permissions: str
        """
        Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        """
        require_sitewide_authentication: bool
        """
        Require user authentication to access any resource protected by this enforcement point.
        """
        resources: Sequence['GetInstanceEnforcementPointResourceArgsDict']
        """
        Array of resource objects
        """
        session_expiry_fixed: 'GetInstanceEnforcementPointSessionExpiryFixedArgsDict'
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        session_expiry_inactivity: 'GetInstanceEnforcementPointSessionExpiryInactivityArgsDict'
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        target: str
        """
        A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        """
        token: str
        """
        Can only be set on create. Access Gateway Token.
        """
        use_target_host_header: bool
        """
        Use the target host header as opposed to the original gateway or upstream host header.
        """
        vhost: str
        """
        A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
elif False:
    GetInstanceEnforcementPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceEnforcementPointArgs:
    def __init__(__self__, *,
                 case_sensitive: bool,
                 conditions: str,
                 context_root: str,
                 landing_page: str,
                 permissions: str,
                 require_sitewide_authentication: bool,
                 resources: Sequence['GetInstanceEnforcementPointResourceArgs'],
                 session_expiry_fixed: 'GetInstanceEnforcementPointSessionExpiryFixedArgs',
                 session_expiry_inactivity: 'GetInstanceEnforcementPointSessionExpiryInactivityArgs',
                 target: str,
                 token: str,
                 use_target_host_header: bool,
                 vhost: str):
        """
        :param bool case_sensitive: The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        :param str conditions: If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        :param str context_root: The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        :param str landing_page: The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        :param str permissions: Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        :param bool require_sitewide_authentication: Require user authentication to access any resource protected by this enforcement point.
        :param Sequence['GetInstanceEnforcementPointResourceArgs'] resources: Array of resource objects
        :param 'GetInstanceEnforcementPointSessionExpiryFixedArgs' session_expiry_fixed: unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        :param 'GetInstanceEnforcementPointSessionExpiryInactivityArgs' session_expiry_inactivity: unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        :param str target: A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        :param str token: Can only be set on create. Access Gateway Token.
        :param bool use_target_host_header: Use the target host header as opposed to the original gateway or upstream host header.
        :param str vhost: A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "context_root", context_root)
        pulumi.set(__self__, "landing_page", landing_page)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "require_sitewide_authentication", require_sitewide_authentication)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "session_expiry_fixed", session_expiry_fixed)
        pulumi.set(__self__, "session_expiry_inactivity", session_expiry_inactivity)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "use_target_host_header", use_target_host_header)
        pulumi.set(__self__, "vhost", vhost)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> bool:
        """
        The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: bool):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter
    def conditions(self) -> str:
        """
        If access is conditional, the conditions that must evaluate to true to allow access to a resource. For example, to require the user must be authenticated and have either the role Admin or User
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: str):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> str:
        """
        The root path to the application, often the name of the application. Can be any name, path or just a slash (“/”). The context root uniquely identifies the application within the enforcement point.
        """
        return pulumi.get(self, "context_root")

    @context_root.setter
    def context_root(self, value: str):
        pulumi.set(self, "context_root", value)

    @property
    @pulumi.getter(name="landingPage")
    def landing_page(self) -> str:
        """
        The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.
        """
        return pulumi.get(self, "landing_page")

    @landing_page.setter
    def landing_page(self, value: str):
        pulumi.set(self, "landing_page", value)

    @property
    @pulumi.getter
    def permissions(self) -> str:
        """
        Specify to always `allow`, `deny` access to resources, of if access is `conditional`.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: str):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter(name="requireSitewideAuthentication")
    def require_sitewide_authentication(self) -> bool:
        """
        Require user authentication to access any resource protected by this enforcement point.
        """
        return pulumi.get(self, "require_sitewide_authentication")

    @require_sitewide_authentication.setter
    def require_sitewide_authentication(self, value: bool):
        pulumi.set(self, "require_sitewide_authentication", value)

    @property
    @pulumi.getter
    def resources(self) -> Sequence['GetInstanceEnforcementPointResourceArgs']:
        """
        Array of resource objects
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Sequence['GetInstanceEnforcementPointResourceArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="sessionExpiryFixed")
    def session_expiry_fixed(self) -> 'GetInstanceEnforcementPointSessionExpiryFixedArgs':
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        return pulumi.get(self, "session_expiry_fixed")

    @session_expiry_fixed.setter
    def session_expiry_fixed(self, value: 'GetInstanceEnforcementPointSessionExpiryFixedArgs'):
        pulumi.set(self, "session_expiry_fixed", value)

    @property
    @pulumi.getter(name="sessionExpiryInactivity")
    def session_expiry_inactivity(self) -> 'GetInstanceEnforcementPointSessionExpiryInactivityArgs':
        """
        unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
        """
        return pulumi.get(self, "session_expiry_inactivity")

    @session_expiry_inactivity.setter
    def session_expiry_inactivity(self, value: 'GetInstanceEnforcementPointSessionExpiryInactivityArgs'):
        pulumi.set(self, "session_expiry_inactivity", value)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        A fully-qualified URL to the internal application including scheme, authority and path. The target host authority must be an IP address, not a hostname.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: str):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Can only be set on create. Access Gateway Token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: str):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="useTargetHostHeader")
    def use_target_host_header(self) -> bool:
        """
        Use the target host header as opposed to the original gateway or upstream host header.
        """
        return pulumi.get(self, "use_target_host_header")

    @use_target_host_header.setter
    def use_target_host_header(self, value: bool):
        pulumi.set(self, "use_target_host_header", value)

    @property
    @pulumi.getter
    def vhost(self) -> str:
        """
        A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: str):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class GetInstanceEnforcementPointResourceArgsDict(TypedDict):
        conditions: str
        """
        required if permission == "conditions"
        """
        is_path_regex: bool
        path: str
        permission: str
        require_auth: bool
elif False:
    GetInstanceEnforcementPointResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceEnforcementPointResourceArgs:
    def __init__(__self__, *,
                 conditions: str,
                 is_path_regex: bool,
                 path: str,
                 permission: str,
                 require_auth: bool):
        """
        :param str conditions: required if permission == "conditions"
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "is_path_regex", is_path_regex)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "require_auth", require_auth)

    @property
    @pulumi.getter
    def conditions(self) -> str:
        """
        required if permission == "conditions"
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: str):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="isPathRegex")
    def is_path_regex(self) -> bool:
        return pulumi.get(self, "is_path_regex")

    @is_path_regex.setter
    def is_path_regex(self, value: bool):
        pulumi.set(self, "is_path_regex", value)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def permission(self) -> str:
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: str):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="requireAuth")
    def require_auth(self) -> bool:
        return pulumi.get(self, "require_auth")

    @require_auth.setter
    def require_auth(self, value: bool):
        pulumi.set(self, "require_auth", value)


if not MYPY:
    class GetInstanceEnforcementPointSessionExpiryFixedArgsDict(TypedDict):
        unit: int
        value: int
elif False:
    GetInstanceEnforcementPointSessionExpiryFixedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceEnforcementPointSessionExpiryFixedArgs:
    def __init__(__self__, *,
                 unit: int,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> int:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: int):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetInstanceEnforcementPointSessionExpiryInactivityArgsDict(TypedDict):
        unit: int
        value: int
elif False:
    GetInstanceEnforcementPointSessionExpiryInactivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceEnforcementPointSessionExpiryInactivityArgs:
    def __init__(__self__, *,
                 unit: int,
                 value: int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> int:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: int):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetInstanceParametersArgsDict(TypedDict):
        groups: 'GetInstanceParametersGroupsArgsDict'
elif False:
    GetInstanceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceParametersArgs:
    def __init__(__self__, *,
                 groups: 'GetInstanceParametersGroupsArgs'):
        pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def groups(self) -> 'GetInstanceParametersGroupsArgs':
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: 'GetInstanceParametersGroupsArgs'):
        pulumi.set(self, "groups", value)


if not MYPY:
    class GetInstanceParametersGroupsArgsDict(TypedDict):
        attributes_transformations: str
        default_values: str
        id: int
        label: str
        provisioned_entitlements: bool
        skip_if_blank: bool
        user_attribute_macros: str
        user_attribute_mappings: str
        values: str
elif False:
    GetInstanceParametersGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceParametersGroupsArgs:
    def __init__(__self__, *,
                 attributes_transformations: str,
                 default_values: str,
                 id: int,
                 label: str,
                 provisioned_entitlements: bool,
                 skip_if_blank: bool,
                 user_attribute_macros: str,
                 user_attribute_mappings: str,
                 values: str):
        pulumi.set(__self__, "attributes_transformations", attributes_transformations)
        pulumi.set(__self__, "default_values", default_values)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "provisioned_entitlements", provisioned_entitlements)
        pulumi.set(__self__, "skip_if_blank", skip_if_blank)
        pulumi.set(__self__, "user_attribute_macros", user_attribute_macros)
        pulumi.set(__self__, "user_attribute_mappings", user_attribute_mappings)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="attributesTransformations")
    def attributes_transformations(self) -> str:
        return pulumi.get(self, "attributes_transformations")

    @attributes_transformations.setter
    def attributes_transformations(self, value: str):
        pulumi.set(self, "attributes_transformations", value)

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> str:
        return pulumi.get(self, "default_values")

    @default_values.setter
    def default_values(self, value: str):
        pulumi.set(self, "default_values", value)

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: int):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: str):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="provisionedEntitlements")
    def provisioned_entitlements(self) -> bool:
        return pulumi.get(self, "provisioned_entitlements")

    @provisioned_entitlements.setter
    def provisioned_entitlements(self, value: bool):
        pulumi.set(self, "provisioned_entitlements", value)

    @property
    @pulumi.getter(name="skipIfBlank")
    def skip_if_blank(self) -> bool:
        return pulumi.get(self, "skip_if_blank")

    @skip_if_blank.setter
    def skip_if_blank(self, value: bool):
        pulumi.set(self, "skip_if_blank", value)

    @property
    @pulumi.getter(name="userAttributeMacros")
    def user_attribute_macros(self) -> str:
        return pulumi.get(self, "user_attribute_macros")

    @user_attribute_macros.setter
    def user_attribute_macros(self, value: str):
        pulumi.set(self, "user_attribute_macros", value)

    @property
    @pulumi.getter(name="userAttributeMappings")
    def user_attribute_mappings(self) -> str:
        return pulumi.get(self, "user_attribute_mappings")

    @user_attribute_mappings.setter
    def user_attribute_mappings(self, value: str):
        pulumi.set(self, "user_attribute_mappings", value)

    @property
    @pulumi.getter
    def values(self) -> str:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: str):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetInstanceProvisioningArgsDict(TypedDict):
        enabled: bool
        status: str
elif False:
    GetInstanceProvisioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceProvisioningArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 status: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetInstanceSsoArgsDict(TypedDict):
        acs_url: str
        """
        App Name.	This is only returned after Creating a SAML App.
        """
        certificate: 'GetInstanceSsoCertificateArgsDict'
        """
        The certificate used for signing.	This is only returned after Creating a SAML App.
        """
        client_id: str
        """
        The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        """
        client_secret: str
        """
        OpenId Connet Client Secret
        """
        issuer: str
        """
        Issuer of app.	This is only returned after Creating a SAML App.
        """
        metadata_url: str
        """
        ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
elif False:
    GetInstanceSsoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceSsoArgs:
    def __init__(__self__, *,
                 acs_url: str,
                 certificate: 'GetInstanceSsoCertificateArgs',
                 client_id: str,
                 client_secret: str,
                 issuer: str,
                 metadata_url: str):
        """
        :param str acs_url: App Name.	This is only returned after Creating a SAML App.
        :param 'GetInstanceSsoCertificateArgs' certificate: The certificate used for signing.	This is only returned after Creating a SAML App.
        :param str client_id: The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        :param str client_secret: OpenId Connet Client Secret
        :param str issuer: Issuer of app.	This is only returned after Creating a SAML App.
        :param str metadata_url: ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
        pulumi.set(__self__, "acs_url", acs_url)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "metadata_url", metadata_url)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> str:
        """
        App Name.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "acs_url")

    @acs_url.setter
    def acs_url(self, value: str):
        pulumi.set(self, "acs_url", value)

    @property
    @pulumi.getter
    def certificate(self) -> 'GetInstanceSsoCertificateArgs':
        """
        The certificate used for signing.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: 'GetInstanceSsoCertificateArgs'):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenId Connect Client Id. Note that client_secret is only returned after Creating an OIDC App.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: str):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        OpenId Connet Client Secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: str):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        Issuer of app.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: str):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> str:
        """
        ID of the apps underlying connector.	This is only returned after Creating a SAML App.
        """
        return pulumi.get(self, "metadata_url")

    @metadata_url.setter
    def metadata_url(self, value: str):
        pulumi.set(self, "metadata_url", value)


if not MYPY:
    class GetInstanceSsoCertificateArgsDict(TypedDict):
        id: int
        name: str
        value: str
elif False:
    GetInstanceSsoCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceSsoCertificateArgs:
    def __init__(__self__, *,
                 id: int,
                 name: str,
                 value: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: int):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetRulesActionArgsDict(TypedDict):
        action: str
        """
        The action to apply
        """
        values: Sequence[str]
        """
        Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
elif False:
    GetRulesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRulesActionArgs:
    def __init__(__self__, *,
                 action: str,
                 values: Sequence[str]):
        """
        :param str action: The action to apply
        :param Sequence[str] values: Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to apply
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: str):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRulesConditionArgsDict(TypedDict):
        operator: str
        """
        A valid operator for the selected condition source
        """
        source: str
        """
        source field to check.
        """
        value: str
        """
        A plain text string or valid value for the selected  condition source
        """
elif False:
    GetRulesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRulesConditionArgs:
    def __init__(__self__, *,
                 operator: str,
                 source: str,
                 value: str):
        """
        :param str operator: A valid operator for the selected condition source
        :param str source: source field to check.
        :param str value: A plain text string or valid value for the selected  condition source
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A valid operator for the selected condition source
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: str):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        source field to check.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: str):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        A plain text string or valid value for the selected  condition source
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetRulesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRulesInstanceActionArgsDict(TypedDict):
        action: str
        """
        The action to apply
        """
        values: Sequence[str]
        """
        Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
elif False:
    GetRulesInstanceActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRulesInstanceActionArgs:
    def __init__(__self__, *,
                 action: str,
                 values: Sequence[str]):
        """
        :param str action: The action to apply
        :param Sequence[str] values: Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to apply
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: str):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetRulesInstanceConditionArgsDict(TypedDict):
        operator: str
        """
        A valid operator for the selected condition source
        """
        source: str
        """
        source field to check.
        """
        value: str
        """
        A plain text string or valid value for the selected  condition source
        """
elif False:
    GetRulesInstanceConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRulesInstanceConditionArgs:
    def __init__(__self__, *,
                 operator: str,
                 source: str,
                 value: str):
        """
        :param str operator: A valid operator for the selected condition source
        :param str source: source field to check.
        :param str value: A plain text string or valid value for the selected  condition source
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        A valid operator for the selected condition source
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: str):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        source field to check.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: str):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        A plain text string or valid value for the selected  condition source
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetUsersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
elif False:
    GetUsersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUsersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


